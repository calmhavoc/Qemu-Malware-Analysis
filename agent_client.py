import socket
import subprocess
import os
import time
import sys
# import tqdm

HOST='192.168.122.1'
# HOST='192.168.1.251'
PORT=8080


def transfer(s,path,getput,fsize=0):#,getput="get"):
    BUFSIZE = 4096
    fsize = int(fsize)
    if 'get' in getput:
        # pass
        # Send file to server
        if os.path.exists(path):
            f = open(path,'rb')
            packet = f.read(BUFSIZE)
            while len(packet) > 0:
                s.send(packet)
                packet = f.read(BUFSIZE)
            s.send('Done'.encode())
        else:
            s.send('File not found.'.encode())

    elif 'put' in getput:
        # Recv file from server
        dest = "c:\\Users\\james\\Desktop\\"

        fname = path.split("/")[-1]  # Need to fix this translation from nix to winodwd
        # print(dest+fname)
        # 2: Got command from server; sending "ready" packet
        s.send(b'Ready')
        recieved = 0

        # 4: getting data file
        #progressbar = tqdm.tqdm(range(fsize), "Recv {}".format(fname), unit="B",unit_scale=True,unit_divisor=1024)
        with open(dest+fname,'wb') as f:
         #   for _ in progressbar:
            while True: # fsize:
                    # print("Received {} of {} bytes".format(recieved,fsize))
                    data = s.recv(BUFSIZE)
                    if not data:
                        break

                    # f.write(data)
                    # progressbar.update(len(data))
                    elif data.endswith(b'__EOF'):
                        data = data[:-5]
                        f.write(data)
                        break
                    else:
                        f.write(data)
                        recieved += BUFSIZE




def run_bg(s,bgcmd):
    try:
        subprocess.Popen(bgcmd,shell=True,stdout=None,stderr=None,close_fds=True)
        print('executed: ',' '.join(bgcmd))
        return True

    except Exception as e:
        return False

def autorun(s):
    WINDST = "c:\\Users\\james\\desktop\\"
    # run c:\Users\james\desktop\elevate.exe c:\Users\james\desktop\Procmon.exe
    # "procmon.exe", '/minimized', '/quiet', '/backingfile', WINDST + 'report.pml'
    # Execute procmon (test tcpdump on target and host to see which works best)
    # cmd = ["c:\\Users\\james\\desktop\\elevate.exe","c:\\Users\\james\\desktop\\Procmon.exe \
    # /minimized /quiet /backingfile {} report.pml".format(WINDST)]

    cmd = ["c:\\Users\\james\\desktop\\elevate.exe","c:\\Users\\james\\desktop\\Procmon.exe", \
"/minimized", "/quiet", "/BackingFile", "{0}\\report.pml".format(WINDST)]
    # print (' '.join(cmd))
    success = run_bg(s,cmd)

    if success:
        s.send("(c)Procmon executed\n".encode())
        # s.send("Executed: {}\n".format(cmd).encode())
    else: s.send(str(e).encode())

    print(s.recv(1024).decode()) # just print whatever was entered fox X

    ##### Need to repeat the above for each handoff below

    # Execute malware
    cmd = ["c:\\Users\\james\\desktop\\Client.exe"]
    # print (' '.join(cmd))
    success = run_bg(s,cmd)
    if success:
        s.send("(c)Malware executed\n".encode())
    else: s.send(str(e).encode())
    # wait for user input to continue
    print(s.recv(1024).decode()) # print "executed malware" from server

    # Once malware has ran its course, we need to quickly kill procmon and create the csv
    # After this, the VM doesn't need to be resumed again; therefore no more comms after suspend is sent
    cmd = ["c:\\Users\\james\\desktop\\elevate.exe", "c:\\Users\\james\\desktop\\procmon.exe", "/Terminate"]
    # cmd = ["c:\\Users\\james\\desktop\\elevate.exe","c:\\Users\\james\\desktop\\procmon.exe", "/Terminate", "&&", "c:\\Users\\james\\desktop\\elevate.exe","c:\\Users\\james\\desktop\\Procmon.exe","/minimized", "/quiet", "/noconnect", "/OpenLog", "{0}\\report.pml".format(WINDST), "/SaveApplyFilter", "/SaveAs", r"{0}\report.csv".format(WINDST)]
    success = run_bg(s,cmd)

    time.sleep(5)
    cmd = ["c:\\Users\\james\\desktop\\elevate.exe","c:\\Users\\james\\desktop\\Procmon.exe", \
"/minimized", "/quiet", "/noconnect", "/OpenLog", "{0}report.pml".format(WINDST), "/SaveApplyFilter", "/SaveAs", "{0}report.csv".format(WINDST)] 
    # print(cmd)
    success = run_bg(s,cmd)
    # after this we can suspend the VM, dump mem, etc
    if success:
        time.sleep(5)
        while True:
            if os.path.exists(r"c:\Users\james\Desktop\report.csv"):
                s.send("(c) Procmon stopped and csv created\n".format(cmd).encode())
                break
            else:
                print("Waiting for csv")
    else: s.send(str(e).encode())

    # print(s.recv(1024).decode()) # not sure if I need this

    # Create CSV
#     cmd = ["c:\\Users\\james\\desktop\\elevate.exe","c:\\Users\\james\\desktop\\Procmon.exe \
# /Terminate"]
#     success = run_bg(s,cmd)

    # sys.exit()
    # if success:
    #     s.send("Executed: {}\n".format(cmd).encode())
    # else: s.send(str(e).encode())

    # suspend VM
    # send return code to server s.send(b'something')
    # dump memory -> process memory (server)
    # copy filesystem target for processing (server)
    # resume VM (server)
    # copy report.pml and pcap to local (maybe terminate procmon first and copy from mounted vdisk)
    # stop VM 
    # process filesystem if desired
    
    # s.send("Executed\n".encode())
    pass


def connect(host,port):
    s=socket.socket()
    s.connect((host,port))
    while True:
        command = s.recv(1024)
        # print(command.decode()[:6])
        if 'terminate' in command.decode():
            s.shutdown(socket.SHUT_RDWR)
            s.close()
            break
        elif command == "":
            s.send(b"")
        elif 'get' in command.decode():
            path = ' '.join(command.decode().split(" ")[1:])
            try:
                transfer(s, path, 'get')
            except Exception as e:
                print(str(r))
                pass
        elif 'put' in command.decode():
            path = ' '.join(command.decode().split(" ")[1:])
            fsize = path.split(":")[1]
            fpath = path.split(":")[0]
            # path = "c:\\Users\\james\\Desktop\\"
            try:
                transfer(s, fpath,'put',fsize)
            except Exception as e:
                print(str(e))
                pass

        elif command.decode()[:3] == 'run':
            bgcmd = ' '.join(command.decode().split(" ")[1:])
            run_bg(s,bgcmd)
            # print (bgcmd)
            # try:
            #     subprocess.Popen(bgcmd,shell=True,stdout=None,stderr=None,close_fds=True)

            #     s.send("Executed\n".encode())
            # except Exception as e:
            #     s.send(str(e).encode())

        elif command.decode()[:7] == 'autorun':
            autorun(s)
        # elif '' in command.decode():
        #     s.send(b'')

        else:
            # print(command.decode())
            with subprocess.Popen(command.decode(),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) as cmd:
                # s.settimeout(1)
                try:
                    out = cmd.stdout.read()
                    err = cmd.stderr.read()
                    if len(out) > 0 or len(err) > 0:
                        s.send(out)
                        s.send(err)     
                    else:
                        s.send(b"No data")


                except Exception as e: #TimeoutExpired: # #
                    s.send(str(e).encode())
                    s.shutdown(socket.SHUT_RDWR)
                    s.close()
                    # time.sleep(2)
                    # connect(host,port)


def main(host,port):
    while True: 
        # try:
        connect(host,port)
        # except Exception as e:
        #     print('exception in main')
        #     print(str(e))
        #     sleep(2)




main(HOST,PORT)