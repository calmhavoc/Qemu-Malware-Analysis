import socket
import os
import subprocess
import time
import tqdm

# pip3 install tqdm

HOST = '0.0.0.0'
PORT = 8080


def autorun(conn):
    # revert vm to snapshot
    # pass
    # revert vm to snapshot with vimsh
    # virsh snapshot-revert <image name> --snapshotname <snapname>
    # command = "virsh snapshot-revert win7 --snapshotname snapshot2"
    # c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    
    ##print(s.recv(1024).decode())


    # Revert to base snapshot
    # !FIX don't do this part until rewriting async coms
    command = "virsh snapshot-revert win7 --snapshotname base"
    print(command)
    # c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    time.sleep(10)

    # Copy malware to target
    malware_dir = "./malware" # temp malware directory; fix later


    for f in os.listdir(malware_dir):
        # print("Uploading "+f)
        fpath = malware_dir+os.path.sep+f
        # print(fpath)
        putfile(conn,"put "+fpath)
        time.sleep(2)
    print('done')
    input("Files copied. Press enter when ready to execute procmon ") # Need to filter on specific malware

    # Start autorun process on client
    conn.send('autorun'.encode())
    print(conn.recv(1024).decode()) # Get return from procmon execution


    x = input("Enter when ready to execute malware")
    conn.send("Execute Malware".encode())
    print(conn.recv(1024).decode()) # Get Malware Executed response





    # time.sleep(10)
    # input("Enter ")

    # Pause to test malware
    x = input("Enter when ready to kill procmon and suspend vm")
    conn.send("Terminating Procmon; then suspending VM".encode())

    print(conn.recv(1024).decode())  # Print the "procmon stopped, csv created message" message

    # Wait for ready to suspend and process server side items
    # print(conn.recv(1024).decode())
    # input("Enter when ready to kill procmon")
    # Procmon Killed, CSV created



    # suspend VM
    # time.sleep(10)
    input("Enter to suspend")
    command = "virsh suspend win7"
    print(command)
    c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

    time.sleep(5)




    # time.sleep(5)
    # input("Enter when ready to suspend")

    # # Wait until report.csv is available 
    # while True:
    #     if os.path.exists('/mnt/tmp/Users/james/Desktop/report.csv'):
    #         break
    #     else:
    #         time.sleep(3)
    #         print("Waiting for report.csv")

    # dump memory -> process memory
    command = "virsh dump win7 --memory-only /tmp/memout.dmp"
    print(command)
    c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)



    # Resume snapshot to get the report.csv file
    command = "virsh resume win7"
    print(command)
    c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

    fpath = r"c:\Users\james\Desktop\report.csv"
    getfile(conn,"get "+fpath)

    #     # mount disk read only  (server)
    # print("Mounting")
    # command = "guestmount -a /var/lib/libvirt/images/win7.qcow2 -r -i /mnt/tmp/"
    # print(command)
    # c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

    # # Wait until mounted 
    # while True:
    #     if os.path.exists('/mnt/tmp/Users'):
    #         break
    #     else:
    #         time.sleep(3)
    #         print("Waiting for mount")

    # # copy report.csv from vdisk
    # command = "cp -f /mnt/tmp/Users/james/Desktop/report.csv /tmp/"
    # print(command)
    # c = subprocess.Popen(command.split(' '),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

    # time.sleep(2)
    # # unmount the vdisk
    # command = "umount /mnt/tmp"
    # print(command)
    # c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)


    ####################
    # Done with main
    # Now for automated processing
    ######################3





    # resume VM (server)
    pass

def local_exec(command):
    with subprocess.Popen(command.decode(),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) as cmd:
        # s.settimeout(1)
        try:
            out = cmd.stdout.read()
            err = cmd.stderr.read()
            if len(out) > 0 or len(err) > 0:
                s.send(out)
                s.send(err)     
            else:
                s.send(b"No data")


        except Exception as e: #TimeoutExpired: # #
            s.send(str(e).encode())
            s.shutdown(socket.SHUT_RDWR)
            s.close()


def getfile(c,cmd):#,fname):
    path = ' '.join(cmd.split(" ")[1:])
    fname = path.split("\\")[-1]
    c.send(cmd.encode())
    f = open(fname,'wb')
    while True :
        data = c.recv(1024)
        if data.endswith(data[:-4]):
            f.close()
            print('[+] File Transfered')
            break
        if 'File not found'.encode() in data:
            print('File not found')
            break
        f.write(data)


def putfile(c,cmd):#,fname):
    BUFSIZE = 1024
    fpath = ' '.join(cmd.split(" ")[1:])
    # print(fpath)
    fname = fpath.split("/")[-1]  # Fix this so it works regardless of OS server is on
    if os.path.exists(fpath):
        fsize = os.path.getsize(fpath)
        cmd += ":{}".format(fsize)
        # 1: send initial put command to tell client to receive 
        c.send(cmd.encode())
        # ready = c.recv(BUFSIZE)  # recieve "ready" from client, in the put function
        # print(ready.decode())

        # 3: got ready packet, start sending file
        progressbar = tqdm.tqdm(range(fsize), "Sending {}".format(fname), unit="B",unit_scale=True,unit_divisor=1024)
        with open(fpath,'rb') as f:
            for _ in progressbar:
                data = f.read(BUFSIZE)
                if not data:
                    c.send(b"__EOF")
                    break
                c.sendall(data)
                progressbar.update(len(data))

            # while True:
            #     data = f.read(BUFSIZE)
            #     if not data:
            #         print("NO DATA:{}".format(len(data)))
            #         c.send(b"__EOF")
            #         break
            #     else:
                    # s.sendall(data)
                    # print("data")
                    # c.sendall(data)
                    # progressbar.update(len(data))

        # 6 get the "finished" packet from client
        ret = c.recv(BUFSIZE).decode() # The "Ready" packet


        # c.close()

        # s.close()
        # while len(data) > 0:
        #     # print(".",end="")
        #     # print('sending: {}'.format(len(data)))
        #     s.send(data)
        #     data = f.read(BUFSIZE)

        # print('Done')
        # # s.send(b'__EOF')
        # s.sendall(data)
        # print(s.recv(BUFSIZE).decode())

        # s.shutdown(socket.SHUT_WR)

    else:
        print(fpath)
        s.send('File not found.'.encode())


def connect(host,port):
    s = socket.socket()
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind((host,port))
    s.listen(1)
    conn, addr = s.accept()
    print('[+] {} connected'.format(addr[0]))

    while True:
        command = input(">>> ")
        if 'terminate' in command:
            conn.send('terminate'.encode())
            conn.shutdown(socket.SHUT_RDWR)
            conn.close()
            break
        elif 'get' in command:
            getfile(conn,command)
        elif 'put' in command:
            putfile(conn,command)
        elif 'autorun' in command:
            autorun(conn)
        elif command == '':
            print("Null Command")
            conn.send(b"")
        else:
            conn.send(command.encode())
            print(conn.recv(1024).decode())



def main():
    connect(HOST,PORT)

main()
