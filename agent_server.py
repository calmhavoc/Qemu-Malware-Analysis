import socket
import os
import subprocess
import time
import tqdm

# pip3 install tqdm

# HOST = '0.0.0.0'
# PORT = 8080


class Server(object):
    def __init__(self): #, host, port):
        # self.host = "" #host
        # self.port = "" #port
        self.imagename = "" #"win7"
        self.snapname = "" #"base"
        self.localmaldir = "" #"./malware"
        self.executable = "" #"test.exe"
        self.windst = "" #"c:\\Windows\\Temp\\"
        self.localoutputdir = "./outdir/"
        self.remoteuser = ""
        self.runtime = ""
        #self.connect(host,port)


    def autorun(self,conn):
        # !FIX don't do this part until writing async coms

        time.sleep(10)

        # Copy malware to target
        malware_dir = self.localmaldir #"./malware" # temp malware directory; fix later

        if malware_dir is not None:
            for f in os.listdir(malware_dir):
                # print("Uploading "+f)
                fpath = malware_dir+os.path.sep+f
                # print(fpath)
                self.putfile(conn,"put "+fpath)
                time.sleep(2)
            print('Copied all files')
        else:
            try:
                self.putfile(conn,"put " + self.executable)
            except Exception as e:
                print ("Could not copy: ")
                print (str(e))
                return 1
        print("Files copied, executing Procmon ") # Need to filter on specific malware

        # Start autorun process on client
        conn.send('autorun'.encode())
        print(conn.recv(1024).decode()) # Get return from procmon execution

        print("Executing malware for {} seconds".format(int(self.runtime)))
        # x = input("Enter when ready to execute malware")

        # conn.send("Execute Malware".encode())
        conn.send("{}{}".format(self.windst, self.executable).encode())
        print(conn.recv(1024).decode()) # Get Malware Executed response
        time.sleep(self.runtime)


        # Pause to test malware
        # x = input("Enter when ready to kill procmon and suspend vm")
        print("Terminating procmon and suspending VM for memory dump")
        conn.send("Terminating Procmon; then suspending VM".encode())

        """ NEED TO MAKE THIS A CONDITIONAL """

        print(conn.recv(1024).decode())  # Print the "procmon stopped, csv created message" message

        # Wait for ready to suspend and process server side items
        # print(conn.recv(1024).decode())
        # input("Enter when ready to kill procmon")
        # Procmon Killed, CSV created



        # time.sleep(10)
        # input("Enter to suspend")
        command = "virsh suspend {name}".format(name=self.imagename)
        # print(command)
        c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        out,err = c.communicate()

        time.sleep(5)


        # # Wait until report.csv is available 
        # while True:
        #     if os.path.exists('/mnt/tmp/Users/james/Desktop/report.csv'):
        #         break
        #     else:
        #         time.sleep(3)
        #         print("Waiting for report.csv")

        # dump memory -> process memory
        command = "virsh dump {name} --memory-only {memdump}".format(name=self.imagename, memdump="/tmp/memout.dmp")
        print(command)
        c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)



        # Resume snapshot to get the report.csv file
        command = "virsh resume {name}".format(name = self.imagename)
        print(command)
        c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        out,err = c.communicate()

        fpath = self.windst+"report.csv".format(username=self.remoteuser)
        self.getfile(conn,"get "+fpath)

        # print(conn.recv(1024).decode())  # Get final message and return shell


        command = "virsh suspend {name}".format(name=self.imagename)
        # print(command)
        c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        out,err = c.communicate()

        exit("Finished")

        #     # mount disk read only  (server)
        # print("Mounting")
        # command = "guestmount -a /var/lib/libvirt/images/win7.qcow2 -r -i /mnt/tmp/"
        # print(command)
        # c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

        # # Wait until mounted 
        # while True:
        #     if os.path.exists('/mnt/tmp/Users'):
        #         break
        #     else:
        #         time.sleep(3)
        #         print("Waiting for mount")

        # # copy report.csv from vdisk
        # command = "cp -f /mnt/tmp/Users/james/Desktop/report.csv /tmp/"
        # print(command)
        # c = subprocess.Popen(command.split(' '),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)

        # time.sleep(2)
        # # unmount the vdisk
        # command = "umount /mnt/tmp"
        # print(command)
        # c = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)


        ####################
        # Done with main
        # Now for automated processing
        ######################3





        # resume VM (server)
        pass

    def local_exec(self,command):
        with subprocess.Popen(command.decode(),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE) as cmd:
            # s.settimeout(1)
            try:
                out = cmd.stdout.read()
                err = cmd.stderr.read()
                if len(out) > 0 or len(err) > 0:
                    s.send(out)
                    s.send(err)     
                else:
                    s.send(b"No data")


            except Exception as e: #TimeoutExpired: # #
                s.send(str(e).encode())
                s.shutdown(socket.SHUT_RDWR)
                s.close()


    def getfile(self,c,cmd):#,fname):
        path = ' '.join(cmd.split(" ")[1:])
        fname = path.split("\\")[-1]
        c.send(cmd.encode())
        f = open(fname,'wb')
        while True :
            data = c.recv(1024)
            if data.endswith(data[:-4]):
                f.close()
                print('[+] File Transfered')
                break
            if 'File not found'.encode() in data:
                print('File not found')
                break
            f.write(data)


    def putfile(self,c,cmd):#,fname):
        BUFSIZE = 1024
        fpath = ' '.join(cmd.split(" ")[1:])
        # print(fpath)
        fname = fpath.split("/")[-1]  # Fix this so it works regardless of OS server is on
        if os.path.exists(fpath):
            fsize = os.path.getsize(fpath)
            cmd += ":{}".format(fsize)
            # 1: send initial put command to tell client to receive 
            c.send(cmd.encode())
            # ready = c.recv(BUFSIZE)  # recieve "ready" from client, in the put function
            # print(ready.decode())

            # 3: got ready packet, start sending file
            progressbar = tqdm.tqdm(range(fsize), "Sending {}".format(fname), unit="B",unit_scale=True,unit_divisor=1024)
            with open(fpath,'rb') as f:
                for _ in progressbar:
                    data = f.read(BUFSIZE)
                    if not data:
                        c.send(b"__EOF")
                        break
                    c.sendall(data)
                    progressbar.update(len(data))

                # while True:
                #     data = f.read(BUFSIZE)
                #     if not data:
                #         print("NO DATA:{}".format(len(data)))
                #         c.send(b"__EOF")
                #         break
                #     else:
                        # s.sendall(data)
                        # print("data")
                        # c.sendall(data)
                        # progressbar.update(len(data))

            # 6 get the "finished" packet from client
            ret = c.recv(BUFSIZE).decode() # The "Ready" packet


            # c.close()

            # s.close()
            # while len(data) > 0:
            #     # print(".",end="")
            #     # print('sending: {}'.format(len(data)))
            #     s.send(data)
            #     data = f.read(BUFSIZE)

            # print('Done')
            # # s.send(b'__EOF')
            # s.sendall(data)
            # print(s.recv(BUFSIZE).decode())

            # s.shutdown(socket.SHUT_WR)

        else:
            print(fpath)
            s.send('File not found.'.encode())


    def connect(self,host,port,autorun=False):
        s = socket.socket()
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        s.bind((host,port))
        s.listen(1)
        conn, addr = s.accept()
        print('[+] {} connected'.format(addr[0]))
        
        if autorun:
            self.autorun(conn)

        while True:
            command = input(">>> ")
            if 'terminate' in command:
                conn.send('terminate'.encode())
                conn.shutdown(socket.SHUT_RDWR)
                conn.close()
                break
            elif 'get' in command:
                self.getfile(conn,command)
            elif 'put' in command:
                self.putfile(conn,command)
            elif 'autorun' in command:
                self.autorun(conn)
            elif command == '':
                print("Null Command")
                conn.send(b"")
            else:
                conn.send(command.encode())
                print(conn.recv(4096).decode())



# host = "0.0.0.0"
# port = 8080
# start = Server(host,port)

if __name__ == "__main__":
    import qemu_handler as qh 

    # imagename = "win7"
    # snapname = "base"
    # localmaldir = "./malware"
    # executable = "Client.exe"
    # remoteuser = "james"
    # windst = "c:\\Windows\\Temp\\"


    # def begin_autorun(imagename, snapname):
    #     cmd = qh.get_commands(command = "snap_revert",name=imagename, snapname=snapname)
    #     out,err = qh.run_command(cmd)
    #     print(out)
    #     print(err)

    # begin_autorun("win7","base")

    start = Server()

    # start.imagename = imagename
    # start.snapname = snapname
    # start.localmaldir = localmaldir
    # start.executable = executable
    # start.windst = windst


    host = "0.0.0.0"
    port = 8080

    start.connect(host,port)
